module Simulator

using ..CustomStructs
using LinearAlgebra, SatelliteDynamics, EarthAlbedo

include("simulator_config_file.jl")
include("../rotationFunctions.jl")
include("../mag_field.jl")

# Primary functions
export rk4
export generate_measurements

# Simulator options:
export SIM


####################################################################
#                         SOFTWARE                                 #
####################################################################

struct SIM # For now, just used for multiple dispatch 
    junk
end

# Bias...? 
function dynamics(sat::SATELLITE, x, u, t)
    """ Propagates state dynamics.  Called in _____. Assumes t includes epoch already """

    if norm(x[1:3]) < 6378136.3 # Satellite has crashed!
        error("Impact at time $t")
    end

    ṙ = x[4:6]
    v̇ = accel_perturbations(t, x[1:6]);

    w = x[11:13] # angular velocity 
    q̇ = 0.5 * qmult(x[7:10], [w; 0]) # Scalar LAST quaternion

    J = sat.J
    ẇ = (J^(-1)) * (u - cross(w, (J*w)))
    # ẇ = J \ (u - cross(w, J*w))

    σβ = 0.05 * deg2rad(0.05)  #0.22
    δβ = σβ * randn(3)  #β̇  looks funny so I am using δ

    return [ṙ[:]; v̇[:]; q̇[:]; ẇ[:]; δβ[:]]
end

    function accel_perturbations(epc::Epoch, x::Array{<:Real} ;
        mass::Real=1.0, area_drag::Real=0.01, coef_drag::Real=2.3,
        area_srp::Real=1.0, coef_srp::Real=1.8,
        n_grav::Integer=10, m_grav::Integer=10)
        """Accelerations for spacecraft in LEO, ForwardDiff friendly"""

        # Extract position and velocity
        r = x[1:3]
        v = x[4:6]

        # Compute ECI to ECEF Transformation -> IAU2010 Theory
        PN = bias_precession_nutation(epc)
        E  = earth_rotation(epc)
        W  = polar_motion(epc)
        R  = W * E * PN

        # Compute sun and moon position
        r_sun  = sun_position(epc)
        r_moon = moon_position(epc)

        # Compute acceleration (eltype(x) makes this forward diff friendly)
        a = zeros(eltype(x), 3)

        # spherical harmonic gravity
        a += accel_gravity(x, R, n_grav, m_grav)

        # atmospheric drag
        ρ = density_harris_priester(epc,r)
        a += accel_drag([r;v],ρ,mass, area_drag, coef_drag, Array{Real, 2}(PN))

        # SRP
        nu = eclipse_conical(x, r_sun)
        a += nu*accel_srp(x, r_sun, mass, area_srp, coef_srp)

        # third body sun
        a += accel_thirdbody_sun(x, r_sun)

        # third body moon
        a += accel_thirdbody_moon(x, r_moon)

        return a
    end

    # NOT a standard rk4
    function rk4(model,x_n,u,t_n,h)
        """ 
            Modified rk4 function (from Kevin)
        """

        k1 = h * dynamics(model, x_n, u, t_n)
        k2 = h * dynamics(model, x_n + k1/2, u, t_n + h/2)
        k3 = h * dynamics(model, x_n + k2/2, u, t_n + h/2)
        k4 = h * dynamics(model, x_n + k3, u, t_n + h)

        return (x_n + (1/6)*(k1+2*k2+2*k3 + k4))
    end


        
# Still relies on old faulty eclipse, noise not all in 
# No vectors are normed... yet?
function generate_measurements(sim::SIM, sat::SATELLITE, alb::ALBEDO, x, t, CONSTANTS, dt)
    """ Generates sensor measurements. sat_truth, Called in _____"""
    pos = x[1:3]
    q⃗ = x[7:9]; q₀ = x[10] # Vector, Scalar portions

    ᴺRᴮ = I(3) + 2 * hat(q⃗) * (q₀ * I(3) + hat(q⃗)); # Equation from Kevin, quaternion -> DCM (eq 39)
    ᴮRᴺ = transpose(ᴺRᴮ) # N -> B

    sᴵ = sun_position(t)  # Sun-Earth vector
    ecl = eclipse_conical(-pos, sᴵ)
    sᴵ = sᴵ - pos         # Sun-Sat vector

    albedo_matrix, junk = albedo(pos, sᴵ, alb.refl)

    sᴵ = ecl * (sᴵ) # / norm(sᴵ))

    Bᴵ = IGRF13(pos, t)
    # Bᴵ = Bᴵ / norm(Bᴵ)

    truth = GROUND_TRUTH(t, Bᴵ, sᴵ)

    η_sun = I(3) #generate_noise_matrix(deg2rad(5.0), dt)
    η_mag = I(3) #generate_noise_matrix(deg2rad(5.0), dt)

    sᴮ = η_sun * (ᴮRᴺ * (sᴵ))# / norm(sᴵ))) # (noisy) Sun vector in body frame
    Bᴮ = η_mag * (ᴮRᴺ * (Bᴵ))# / norm(Bᴵ))) # (noisy) Mag vector in body frame

    ŝᴮ = η_sun * (ᴮRᴺ * (sᴵ / norm(sᴵ))) # Make it unit...?
    B̂ᴮ = η_mag * (ᴮRᴺ * (Bᴮ / norm(Bᴮ)))

    num_diodes = size(sat.diodes.calib_values, 1)
    current_vals = zeros(num_diodes) # Currents being generated by each photodiode
    diode_albedos = zeros(num_diodes)

    ϵ = sat.diodes.elev_angles 
    α = sat.diodes.azi_angles
    C = sat.diodes.calib_values
    for i = 1:num_diodes 
        surface_normal = [(cos(ϵ[i])*cos(α[i])) (cos(ϵ[i])*sin(α[i])) sin(ϵ[i])]   # Photodiode surface normal 

        diode_albedo = compute_diode_albedo(albedo_matrix, alb.cell_centers_ecef, surface_normal, pos)

        ##### ADD IN NOISE
        current = (C[i] * surface_normal * ŝᴮ) .+ (C[i] * diode_albedo / CONSTANTS._E_am0) # .+ σ_η_cur * randn() # Calculate current, including noise and Earth's albedo 

        current_vals[i] = current[1] * ecl 

        diode_albedos[i] = C[i] * (diode_albedo / CONSTANTS._E_am0)
    end


    current_vals[current_vals .< 0] .= 0 # Photodiodes don't generate negative current

    # ESTIMATE SUN VECTOR...? -> Probably dont do here
    # surface_normals = []
    # measured_current = []
    # empty_flag = true
    # for i = 1:num_diodes 
    #     if current_vals[i] != 0.0 
    #         if empty_flag
    #             surface_normals = [(cos(ϵ[i])*cos(α[i])) (cos(ϵ[i])*sin(α[i])) sin(ϵ[i])]
    #             measured_current = current_vals[i] / C[i]
    #             empty_flag = false
    #         else
    #             surface_normal = [(cos(ϵ[i])*cos(α[i])) (cos(ϵ[i])*sin(α[i])) sin(ϵ[i])]
    #             surface_normals = [surface_normals; surface_normal]
    
    #             measured_current = [measured_current; current_vals[i]/C[i]]
    #         end
    #     end 
    # end

    # if size(measured_current, 1) < 3
    #     println("ERROR! Not enough diodes illuminated")
    # end
    # sun_vec_est = ((surface_normals' * surface_normals)^(-1)) * (surface_normals' * measured_current)

    # # ################## ALT TO GET EARTH TOO?

    # R = dcm_from_q(x[7:10])
    # A = []
    # measured_current = []
    # empty_flag = true
    # _E_am0 = 1366.9

    # for i = 1:num_diodes 
    #     if current_vals[i] != 0.0 
    #         if empty_flag
    #             x = (cos(ϵ[i])*cos(α[i]))
    #             y = (cos(ϵ[i])*sin(α[i]))
    #             z = sin(ϵ[i])
    #             A = [x y z ((x*R[1,1]+y*R[2,1]+z*R[3,1])/_E_am0) ((x*R[1,2]+y*R[2,2]+z*R[3,2])/_E_am0) ((x*R[1,3]+y*R[2,3]+z*R[3,3])/_E_am0)]
    #             measured_current = current_vals[i] / C[i]
    #             empty_flag = false
    #         else
    #             x = (cos(ϵ[i])*cos(α[i]))
    #             y = (cos(ϵ[i])*sin(α[i]))
    #             z = sin(ϵ[i])
    #             row = [x y z ((x*R[1,1]+y*R[2,1]+z*R[3,1])/_E_am0) ((x*R[1,2]+y*R[2,2]+z*R[3,2])/_E_am0) ((x*R[1,3]+y*R[2,3]+z*R[3,3])/_E_am0)]
    #             A = [A; row]
    #             measured_current = [measured_current; current_vals[i]/C[i]]
    #         end
    #     end 
    # end

    # println("Size A: ", size(A))
    # sol = ((A' * A)^(-1))*(A' * measured_current)
    # sun_est = sol[1:3]
    # pos_est = sol[1:3]

    # p̂ = x[1:3] / norm(x[1:3])
    # println("SUN: $ŝᴮ  |  Est: $sun_est     (Error = ", norm(ŝᴮ - sun_est))
    # println("POS: $p̂   |  Est: $pos_est     (Error = ", norm(p̂ - pos_est))
    # # #########################################################################

    mag_calib_matrix = generate_mag_calib_matrix(sat)

    # println("\nBefore Bias: ", (mag_calib_matrix * Bᴮ), " and bias: ", sat.magnetometer.bias)
    Bᴮ = (mag_calib_matrix * Bᴮ) + sat.magnetometer.bias 

    w̃ = x[11:13] + x[14:16] # + η
    pos = x[1:3]
    sensors = SENSORS(Bᴮ, sᴮ, current_vals, w̃, pos)

    return truth, sensors
end


    function generate_noise_matrix(σ, dt)
        """
            Generates a [3 x 3] noise rotation matrix given a standard deviation 
                First generates a noise vector and then converts that into a rotation matrix
                (Note that if the standard deviation provided is 0, the identity matrix is returned)
        """
        if σ != 0.0
            η_vec = σ * randn(3) # Generate a vector 
            skew = hat(η_vec)
            norm_η = norm(η_vec)
    
            R = (I(3) + (skew/norm_η)*sin(norm_η*dt) + ((skew/norm_η)^2)*(1 - cos(norm_η*dt))); # Rodrigues for matrix exponential (?)
        else
            R = I(3)
        end
        
        R = I(3)
        return R
    end

    # ALSO exists in ESTIMATOR...
    function compute_diode_albedo(albedo_matrix, cell_centers_ecef, surface_normal, sat_pos)
        """ 
            Estimates the effect of Earth's albedo on a specific photodiode (by using the surface normal of that diode)
                = cell_albedo * surface_normal^T * r_g, with r_g as a unit vector in the direction of the grid point on Earth
    
            Arguments:
            - albedo_matrix: Albedo values for each cell on the Earth's surface         | [num_lat x num_lon] 
            - surface_normal: Photodiode surface normal                                 | [3,]
            - sat_pos: Cartesian position of satellite                                  | [3,]
    
            Returns:
            - diode_albedo: Total effect of albedo on specified photodiode              | Scalar
        """    
        cell_albedos = zeros(size(albedo_matrix))
    
        rows, cols = size(albedo_matrix)
        diode_albedo = 0.0
        for r = 1:1:rows
            for c = 1:1:cols
                if albedo_matrix[r,c] != 0
                    r_g = cell_centers_ecef[r,c,:] - sat_pos # Distance from satellite to cell center
                    r_g = r_g / norm(r_g)  # Make unit
    
                    cell_albedo = (albedo_matrix[r,c] * (surface_normal * r_g))[1]
    
                    if cell_albedo > 0.0    # Can't be negative
                        diode_albedo = diode_albedo + cell_albedo 
                    end
                end
            end
        end
        
        return diode_albedo
    end

    function generate_mag_calib_matrix(sat::SATELLITE)
        a, b, c = sat.magnetometer.scale_factors
        ρ, λ, ϕ = sat.magnetometer.non_ortho_angles

        T = [a        0.0              0.0;
            b*sin(ρ)  b*cos(ρ)         0.0;
            c*sin(λ)  c*sin(ϕ)*cos(λ)  c*cos(ϕ)*cos(λ)]

        return T
    end


####################################################################
#                         HARDWARE                                 #
####################################################################
    # function propagate_dynamics()
    # end

    # function generate_measurements()
    # end


end
module Simulator

using ..CustomStructs
using LinearAlgebra, SatelliteDynamics, EarthAlbedo

include("simulator_config_file.jl")
include("../rotationFunctions.jl")
include("../mag_field.jl")

push!(LOAD_PATH, pwd())


export rk4
export generate_measurements

# OPTIONS
export SIM





####################################################################
#                         SOFTWARE                                 #
####################################################################

struct SIM
    junk
end

    # Bias...? 
    function dynamics(sat::SATELLITE, x, u, t)
        """ Propagates state dynamics.  Called in _____"""

        if norm(x[1:3]) < 6378136.3 # Satellite has crashed!
            error("Impact at time $t")
        end

        ṙ = x[4:6]

        #### ASSUMES t includes epc! No need for mu
        v̇ = accel_perturbations(t, x[1:6]);

        w = x[11:13] # angular velocity 
        q̇ = 0.5 * qmult(x[7:10], [w; 0]) # Scalar LAST quaternion

        J = sat.J

        # ẇ = J \ (u - cross(w, J * w))
        ẇ = (J^(-1)) * (u - cross(w, (J*w)))
    
        σβ = deg2rad(0.22)
        δβ = σβ * randn(3)  #β̇  looks funny so I am using δ

        return [ṙ[:]; v̇[:]; q̇[:]; ẇ[:]; δβ[:]]
    end

        function accel_perturbations(epc::Epoch, x::Array{<:Real} ;
            mass::Real=1.0, area_drag::Real=0.01, coef_drag::Real=2.3,
            area_srp::Real=1.0, coef_srp::Real=1.8,
            n_grav::Integer=10, m_grav::Integer=10)
            """Accelerations for spacecraft in LEO, ForwardDiff friendly"""

            # Extract position and velocity
            r = x[1:3]
            v = x[4:6]

            # Compute ECI to ECEF Transformation -> IAU2010 Theory
            PN = bias_precession_nutation(epc)
            E  = earth_rotation(epc)
            W  = polar_motion(epc)
            R  = W * E * PN

            # Compute sun and moon position
            r_sun  = sun_position(epc)
            r_moon = moon_position(epc)

            # Compute acceleration (eltype(x) makes this forward diff friendly)
            a = zeros(eltype(x), 3)

            # spherical harmonic gravity
            a += accel_gravity(x, R, n_grav, m_grav)

            # atmospheric drag
            ρ = density_harris_priester(epc,r)
            a += accel_drag([r;v],ρ,mass, area_drag, coef_drag, Array{Real, 2}(PN))

            # SRP
            nu = eclipse_conical(x, r_sun)
            a += nu*accel_srp(x, r_sun, mass, area_srp, coef_srp)

            # third body sun
            a += accel_thirdbody_sun(x, r_sun)

            # third body moon
            a += accel_thirdbody_moon(x, r_moon)

            return a
        end

        # Doesn't pass in parameters (does through SAT?). Also, not standard
        function rk4(model,x_n,u,t_n,h)
            """ 
                Modified rk4 function (from Kevin)
            """

            k1 = h * dynamics(model, x_n, u, t_n)
            k2 = h * dynamics(model, x_n + k1/2, u, t_n + h/2)
            k3 = h * dynamics(model, x_n + k2/2, u, t_n + h/2)
            k4 = h * dynamics(model, x_n + k3, u, t_n + h)

            return (x_n + (1/6)*(k1+2*k2+2*k3 + k4))
        end


        
    # Still relies on old faulty eclipse, noise not all in 
    # Clean it up too?
    function generate_measurements(sim::SIM, sat::SATELLITE, alb::ALBEDO, x, t, CONSTANTS)
        """ Generates sensor measurements. sat_truth, Called in _____"""
        pos = x[1:3]
        q⃗ = x[7:9]; q₀ = x[10] # Vector, Scalar portions

        ᴺRᴮ = I(3) + 2 * hat(q⃗) * (q₀ * I(3) + hat(q⃗)); # Equation from Kevin, quaternion -> DCM (eq 39)
        ᴮRᴺ = transpose(ᴺRᴮ) # N -> B

        sᴵ = sun_position(t)  # Sun-Earth vector
        ecl = eclipse_conical(-pos, sᴵ)
        sᴵ = sᴵ - pos         # Sun-Sat vector

        albedo_matrix, junk = albedo(pos, sᴵ, alb.refl)

        sᴵ = ecl * (sᴵ) # / norm(sᴵ))

        Bᴵ = IGRF13(pos, t)
        # Bᴵ = Bᴵ / norm(Bᴵ)

        truth = GROUND_TRUTH(t, Bᴵ, sᴵ)

        η_sun = I(3) #get_noise_matrix(σ_η_sun, dt)
        η_mag = I(3) #get_noise_matrix(σ_η_mag, dt)

        sᴮ = η_sun * (ᴮRᴺ * (sᴵ / norm(sᴵ))) # (noisy) Sun vector in body frame
        Bᴮ = η_mag * (ᴮRᴺ * (Bᴵ / norm(Bᴵ))) # (noisy) Mag vector in body frame

        num_diodes = size(sat.diodes.calib_values, 1)
        current_vals = zeros(num_diodes) # Currents being generated by each photodiode
        diode_albedos = zeros(num_diodes)

        ϵ = sat.diodes.elev_angles 
        α = sat.diodes.azi_angles
        C = sat.diodes.calib_values
        for i = 1:num_diodes 
            surface_normal = [(cos(ϵ[i])*cos(α[i])) (cos(ϵ[i])*sin(α[i])) sin(ϵ[i])]   # Photodiode surface normal 

            diode_albedo = compute_diode_albedo(albedo_matrix, surface_normal, pos)

            ##### ADD IN NOISE
            current = (C[i] * surface_normal * sᴮ) .+ (C[i] * diode_albedo / CONSTANTS._E_am0) # .+ σ_η_cur * randn() # Calculate current, including noise and Earth's albedo 

            current_vals[i] = current[1] * ecl 

            diode_albedos[i] = C[i] * (diode_albedo / CONSTANTS._E_am0)
        end


        current_vals[current_vals .< 0] .= 0 # Photodiodes don't generate negative current

        mag_calib_matrix = generate_mag_calib_matrix(sat)
        # induced_scale_factors = sat.magnetometer.induced_scale_factors
        # mag_field_from_curr = induced_scale_factors * current_vals
        
        # below UNDOES what I want to DO
        # (mag_calib_matrix^(-1)) * ((Bᴮ - mag_field_from_curr) .- sat_truth.magnetometer.bias)

        # VERIFY 
        Bᴮ = (mag_calib_matrix * Bᴮ) + sat.magnetometer.bias #+ mag_field_from_curr

        w̃ = x[11:13] + x[14:16]# + η
        pos = x[1:3]
        sensors = SENSORS(Bᴮ, sᴮ, current_vals, w̃, pos)

        return truth, sensors
    end

        function generate_noise_matrix()
            """ Correct way to add noise to a rotation matrix """
            return I(3)
        end

        function compute_diode_albedo(alb_mat, surf_normal, pos)
            """ Generates effect of Earth's albedo on one diode """
            return 1.0
        end

        function generate_mag_calib_matrix(sat::SATELLITE)
            a, b, c = sat.magnetometer.scale_factors
            ρ, λ, ϕ = sat.magnetometer.non_ortho_angles

            T = [a        0.0              0.0;
                b*sin(ρ)  b*cos(ρ)         0.0;
                c*sin(λ)  c*sin(ϕ)*cos(λ)  c*cos(ϕ)*cos(λ)]

            return T
        end


####################################################################
#                         HARDWARE                                 #
####################################################################
    # function propagate_dynamics()
    # end

    # function generate_measurements()
    # end


end
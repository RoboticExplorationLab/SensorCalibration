using Pkg, Plots

cd(@__DIR__)
Pkg.activate(".")  # Load in the project/manifest file stuff to get right versions
Pkg.instantiate()

using SatelliteDynamics # for mag_field.jl, Geod/ECEF conversions
using StaticArrays # for SVectors, used for speed (?)
using Random       # For generating random numbers (e.g., noise)
using JLD2         # For saving 
using LinearAlgebra 
using MAT          # For loading .mat files (could be done with matlab?)
using ProgressMeter
using EarthAlbedo  # For determining effect of Earth's Albedo

# Random.seed!(623455)

include("mag_field.jl")         # From Kevin, used for IGRF13 
include("rotationFunctions.jl") # Includes common functions for dealing with quaternions

include("satellite_configuration_file.jl") # Includes satellite parameters
# ^ Should I make this a class? Dont have to worry about clearing globals      <-  MODULE!! Do the math, then add in CONSTANTS = (blah: blah, ...)


function rk4(f, params, x_n, h, t_n)
    """ 
        RK4, but with no external force, and parameters passed in instead of u.
            (Based off of code from Kevin)
    """
    x_n = SVector{num_states}(x_n)

    k1 = h*f(x_n, params, t_n)
    k2 = h*f(x_n + k1/2, params, t_n + h/2)
    k3 = h*f(x_n + k2/2, params, t_n + h/2)
    k4 = h*f(x_n + k3, params, t_n + h)

    return (x_n + (1/6)*(k1 + 2*k2 + 2*k3 + k4))
end

# NO reliance on globals (σ_β)
function dynamics(x, param, t) 
    """ 
        Dynamics of the system
          - x: [ [px, py, pz], [vx, vy, vz], [q⃗, q0], [wx, wy, wz], [βx, βy, βz]]     | [16,]  
          - param: Standard Gravitational Parameter, Earth radius,
                satellite orbit radius, and satellite inertial matrix                 | [4,]
          - t: Time (not currently being used, could be useful for better accel)      | Scalar

        (Note that everything is in adjusted units, not necessarily m/s)
    """
    mu, Re, r, J = param   
    xdot = zeros(size(x))

    if norm(x[1:3]) < Re # Check if satellite crashes into Earth
        error("Impact!")
    end

    # dot[px, py, pz] = [vx, vy, vz]
    xdot[1:3] = x[4:6]

    # dot[vx, vy, vz] = a⃗ = -mu r̂ / ||r||^3
    xdot[4:6] = (-mu / (norm(x[1:3])^3)) * x[1:3]

    # dot[q] = 0.5 q ⋅ [w; 0]  (Scalar last quaternions!)
    w = x[11:13]
    xdot[7:10] = 0.5 * qmult(x[7:10], [w; 0])

    # dot[w] = J_inv * (-w x Jw)
    xdot[11:13] = (J^(-1)) * cross(-w, (J*w))

    # bias is just a random walk, so β = β + η
    xdot[14:16] = σ_β * randn(3)   

    return xdot
end 

# TODO: Add in Albedo
function measurement(x, t)  
    """
        Generates system measurements 
          - x: [ [px, py, pz], [vx, vy, vz], [q⃗, q0], [wx, wy, wz], [βx, βy, βz] ]     |  [16,]
          - t: current time since start (adjusted units)                               |  scalar
    """

    t = epc + (t * tscale)
    q_vec = x[7:9];  q_sca = x[10];

    R_B2N = I(3) + 2 * hat(q_vec) * (q_sca * I(3) + hat(q_vec)); # Equation from Kevin, quaternion -> DCM (eq 39)
    R_N2B = transpose(R_B2N)

    pos = x[1:3] * dscale        # Satellite vector in Inertial frame 
    sN = sun_position(t)         # Earth-Sun vector in Inertial frame e
    bN = IGRF13(pos, t)          # Mag vector in Inertial frame      should it be negative...


    # TODO  -    there is an ERROR in eclipse_conical (likely dropped off a sign in C = acos(-dot...)) so I am adding a negative here for now
    ecl = eclipse_conical(-pos, sN) # Determine if there is an eclipse (∈ [0, 1])

    temp_sun = sN;

    sN = sN - pos                # Sat-Sun vector in Inertial fram
    albedo_matrix, unions = EarthAlbedo.albedo(pos, sN, refl)

    sN = ecl * (sN / norm(sN)) # Make unit, zero out if sun is blocked 
    bN = (bN / norm(bN))       # Make unit

    # TODO verify noise magnitude
    η_sun = get_noise_matrix(σ_η_sun, dt)
    η_mag = get_noise_matrix(σ_η_mag, dt)

    sB = η_sun * (R_N2B * sN) # (noisy) Sun vector in body frame
    bB = η_mag * (R_N2B * bN) # (noisy) Mag vector in body frame

    current_vals = zeros(num_diodes) # Currents being generated by each photodiode
    diode_albedos = zeros(num_diodes)

    for i = 1:num_diodes
        surface_normal = [cos(ϵs[i])*cos(αs[i]) cos(ϵs[i])*sin(αs[i]) sin(ϵs[i])]     # Photodiode surface normal 
        diode_albedo = get_diode_albedo_local(albedo_matrix, surface_normal, pos)
        if (diode_albedo / _E_am0) > 1.0
            error("Somehow more light is being reflected than is generated!")
        end

        current = (calib_vals[i]  * surface_normal * sB) .+ (calib_vals[i] * diode_albedo / _E_am0) .+ σ_η_cur * randn() # Calculate current, including noise and Earth's albedo 
        current_vals[i] = current[1] * ecl  # Scale by eclipse factor 
        diode_albedos[i] = calib_vals[i] * (diode_albedo/ _E_am0)
    end

    # NOTE should I do this before or after noise?   ->   Probably before...?
    current_vals[current_vals .< 0] .= 0 # Photodiodes don't generate negative current

    Y =  [sB[:]; bB[:]; sN[:]; bN[:]; ecl; current_vals[:]]
    return Y, diode_albedos[:], reshape(unions, length(unions)), temp_sun[:]
end

function get_noise_matrix(σ, dt)
    """
        Generates a [3 x 3] noise rotation matrix given a standard deviation 
            First generates a noise vector and then converts that into a rotation matrix
            (Note that if the standard deviation provided is 0, the identity matrix is returned)
    """
    if σ != 0.0
        η_vec = σ * randn(3) # Generate a vector 
        skew = hat(η_vec)
        norm_η = norm(η_vec)

        R = (I(3) + (skew/norm_η)*sin(norm_η*dt) + ((skew/norm_η)^2)*(1 - cos(norm_η*dt))); # Rodrigues for matrix exponential (?)
    else
        R = I(3)
    end
    return R
end

function generate_data(x0, T, dt)
    """
        Propagates the system dynamics forward for a specified number of points and updates measurment values
    """
    X = zeros(num_states, T)
    Y = zeros(num_meas, T)
    X[:,1] = x0

    diode_albedos = zeros(num_diodes, T)
    unions = zeros(51840, T)
    sun = zeros(3,T)

    @showprogress "Generating Data" for i = 1:(T-1)
        t = (i - 1) * dt  
        X[:, i + 1] = rk4(dynamics, dynamics_params, X[:,i], dt, t)
        Y[:, i], diode_albedos[:,i], unions[:,i], sun[:,i] = measurement(X[:,i], t)
        # Y[:, i] = measurement(X[:,i], t)
    end
    Y[:,T], diode_albedos[:,T], unions[:,T], sun[:,T] = measurement(X[:,T], (T-1)*dt)
    # Y[:,T] = measurement(X[:,T], (T-1)*dt)

    X[11:13,:] = X[11:13,:] .+ X[14:16,:] # Add in bias to the omega vectors (Note that this is done here so as to not interfere with the dynamics)
    return X, Y, diode_albedos, unions, sun
end

function get_diode_albedo_local(albedo_matrix, surface_normal, sat_pos)
    """ 
        Estimates the effect of Earth's albedo on a specific photodiode (by using the surface normal of that diode)
            = cell_albedo * surface_normal^T * r_g, with r_g as a unit vector in the direction of the grid point on Earth

        Arguments:
        - albedo_matrix: Albedo values for each cell on the Earth's surface         | [num_lat x num_lon] 
        - surface_normal: Photodiode surface normal                                 | [3,]
        - sat_pos: Cartesian position of satellite                                  | [3,]

        Returns:
        - diode_albedo: Total effect of albedo on specified photodiode              | Scalar
    """    
    cell_albedos = zeros(size(albedo_matrix))

    rows, cols = size(albedo_matrix)
    diode_albedo = 0.0
    for r = 1:1:rows
        for c = 1:1:cols
            if albedo_matrix[r,c] != 0
                r_g = cell_centers_ecef[r,c,:] - sat_pos # Distance from satellite to cell center
                r_g = r_g / norm(r_g)  # Make unit

                cell_albedo = (albedo_matrix[r,c] * (surface_normal * r_g))[1]

                if cell_albedo > 0.0    # Can't be negative
                    diode_albedo = diode_albedo + cell_albedo 
                end
            end
        end
    end
    
    return diode_albedo
end

# Load in reflectivity data as a struct 
cell_centers_ecef = get_albedo_cell_centers() ./ dscale
refl_dict = matread("refl.mat")
refl = refl_struct(refl_dict["data"], refl_dict["type"], refl_dict["start_time"], refl_dict["stop_time"])

###### PROPAGATE DYNAMICS #####
states, meas, albedos, unions, sun = generate_data(x0, T, dt)
# states, meas = generate_data(x0, T, dt)  # OR return as a dict...?
println("Finished propagating dynamics")


##### GENERATE MEASUREMENTS #####
# History of respective values 
sB_hist = zeros(3, T)
bB_hist = zeros(3, T)
I_hist  = zeros(num_diodes, T)
sN_hist = zeros(3, T) 
bN_hist = zeros(3, T) 
ecl_hist= zeros(T)    

for i = 1:T 
    sB_hist[:,i] = meas[1:3,i] 
    bB_hist[:,i] = meas[4:6,i] 
    sN_hist[:,i] = meas[7:9,i] 
    bN_hist[:,i] = meas[10:12,i]  
    ecl_hist[i]  = meas[13,i]
    I_hist[:,i] = meas[14:(13+num_diodes),i]
end
println("Finished splitting measurements")


##### SAVE DATA #####
whist = states[11:13,:] / tscale 
biases = states[14:16,:] / tscale
dt = dt * tscale
noiseValues = (σ_η_sun = σ_η_sun, σ_η_mag = σ_η_mag, σ_η_cur = σ_η_cur)

rB1hist = sB_hist; rB2hist = bB_hist; rN1 = sN_hist; rN2 = bN_hist; eclipse = ecl_hist; Ihist = I_hist
pos = states[1:3,:] * dscale


# Adjust to multiple structs: (sensors, environment, state, other, etc...?)
@save "mekf_data.jld2" rB1hist rB2hist rN1 rN2 Ihist whist num_diodes dt calib_vals αs ϵs eclipse noiseValues pos epc
# POS? EPC?

qtrue = states[7:10,:]
btrue = biases

@save "mekf_truth.jld2" qtrue btrue #### POS HERE OR BEFORE?
println("Done Saving")

##### PLOTS #####
display(plot(states[1:3,:]', title = "Positions"))
display(plot(sN_hist', title = "Sun Vector (N)"))
display(plot(bN_hist', title = "Mag Vector (N)"))
display(plot(I_hist', title = "Diode Currents (UNKNOWN UNITS FOR NOW)"))

display(plot(states[14:16,:]', title = "Biases"))
display(plot(states[11:13,:]', title = "W"))

display(plot(albedos', title = "Albedos (% of AM_0)"))



